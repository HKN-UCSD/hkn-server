# HKN Server

## Quick Access To Guides:

- On [adding](./guides/add) new services, entities, controllers, etc.
- On how backend [auth](./guides/authentication) works for local development and production.
- On the structure of our [backend](./guides/backend_api) and the hierarchical connection between its layers.
- On [setting up](./guides/development) (local) development environments.
- On [logging](./guides/logging) and how to add them to the backend codebase.
- On how to use the [custom middlewares](./guides/middlewares) that we have.
- On how to [name](./guides/naming) Mapper functions, Payload classes, etc.
- On how the old, deprecated backend API [works](./guides/old_api) (for historical reasons).
- On how to work with our Controller and endpoints for [Storage](./guides/storage), backed by AWS S3.
- On adding different types of [tests](./guides/testing) for our backend code.
- (**Important**) On a word of [caution](./guides/caution.md) when working on the backend codebase.

## Deploys

- `Production`: https://api.hknucsd.com/
- `Development`: https://dev-api.hknucsd.com/

**tl;dr**

```
npm run start
```

## Commands

- `npm run start`: runs lint, clean, build, then serves on localhost with hot reloading (updates server everytime you change code.)
- `npm run build`: runs ts -> js transpiler (tsc)
- `npm run clean`: rm -rf dist/\* but has cross-env support
- `npm run typeorm`: runs typeorm cli (npx typeorm doesn't work because typeorm doesn't play well with typescript)
- `npm run typeorm:sync`: sync your entities with the postgres db to update database schema
- `npm run postgres:start`: Stops the current postgres container if there is one currently running and starts up a new postgres container.
- `npm run postgres:stop`: Stops the current postgres container if there is one currently running.
- `npm run localpg:start`: Starts up the local postgres docker container, then runs TypeORM's database migration and seeding

## Dependency Injection(DI)

DI is essentially passing in your dependencies as arguments in your constructor. See [this](https://www.sarulabs.com/post/2/2018-06-12/what-is-a-dependency-injection-container-and-why-use-one.html) for further explanation.

Currently in our codebase, for any class that needs DI, we export both the class and an instance of that class, with all the dependencies
passed into the constructor arguments, where the dependencies are also an instance of their respective class.

Examples:

In **src/controllers/UserController.ts**, we need AppUserService and AppUserMapper, so UserController's constructor has two arguments
for that. So, we imported AppUserService/Mapper class and their respective instance (denoted as AppUserServiceImpl and AppUserMapperImpl)
as dependencies to create an instance of UserController (denoted as UserControllerImpl). The result is an instance of the UserController
class:

- `export const UserControllerImpl = new UserController(AppUserServiceImpl, AppUserMapperImpl);`

In **src/services/AppUserService.ts**, we do not need any other dependency for the Service class to work properly, so we can just export
an instance of AppUserService class without needing to import any dependency:

- `export const AppUserServiceImpl = new AppUserService();`

## Directory Structure + Terms

All TypeScript code should be located inside of src for the tsc compiler to pick up the changes. For development hot reloading, we use tsc-watch to do incremental compilation and server rebooting. For further instructions on adding any of the following, _please_ read the corresponding guide in guides/

### index.ts

Entry point of server that delegates to _app.ts_ for initializing and setting up the backend server.

### app.ts

Responsible for applying middlewares onto the server (Express app), running [loaders](https://softwareontheroad.com/ideal-nodejs-project-structure/) to establish resources used in the code, connecting to controllers set up using [routing-controllers](https://github.com/typestack/routing-controllers) and establish any remaining routers separate from controllers.

### config.ts

All environment variables should be loaded here and encapsulated within the global singleton Config object so we don't leak process.envs everywhere.

### Backend Structure (starting in ./src):

Refer to [this](./guides/backend_api/structure.md) documentation

## Docs Generation

API documentation is autogenerated and served at the /api/docs endpoint. The documentation is autogenerated via [class-validator-jsonschema](https://github.com/epiphone/class-validator-jsonschema) and [routing-controllers-openapi](https://github.com/epiphone/routing-controllers-openapi). These libraries grab metadata from the routing-controllers and class-validator libraries to generate OpenAPI specs, which we then serve using [redoc-express](https://www.npmjs.com/package/redoc-express).

The OpenAPI spec is served as a json file at the /api/docs/json endpoint (should probably be /api/docs?json=true but oh well). **You can import this into Postman to generate a collection.**

### Migrations

A db migration encapsulates a change to the database schema. Migration files are stored in **src/migrations**. Please visit [TypeORM's page](https://github.com/typeorm/typeorm/blob/master/docs/migrations.md) on migrations to learn more about them and how to write a migration file. This is part of the 3-step process we have for local testing (_npm run localpg:start_) that guarantees idempotence of tests (when starting
up the postgres container, we will always have the same testing data).

### Seeds

Seeding a DB means providing initial data to a DB when the DB is set up initially. Seed files are stored in **src/seeds**. We currently use
this to populate a DB with initial data after a migration. This is also part of the 3-step process we have for local testing (_npm run localpg:start_) that guarantees idempotence of tests.

### Tests

Ignore for now - don't think mocking is worth the effort. Future ideas include standing up a Docker container with a Postgres db running on localhost and pointing tests at that instead. Or run sqlite in memory.
